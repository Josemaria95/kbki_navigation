#!/usr/bin/env python
from __future__ import print_function
import numpy as np
import matplotlib.pyplot as plt
from geometry_msgs.msg import Twist , Pose
from nav_msgs.msg import Odometry, OccupancyGrid, MapMetaData 
from kbki_tesis.msg import Obst, Obst_map
import copy
import rospy
import time

class SlamInterface(object):

	def __init__ (self):

		self.pub = rospy.Publisher("/map_index",Obst_map,queue_size=10, latch=True)
		self.obst_map = Obst_map()
		# Subscribir al topico /map
		rospy.Subscriber("/map",OccupancyGrid, self.readMap)
		self.gridX = None #360 * [0.,]
		self.gridY = None #360 * [0.,]
		self.width  = None
		self.height = None
		self.resolution = None
		self.pose_x = None
		self.pose_y = None
		self.tamano = None
		self.step   = None

	def readMap(self,msg):

		#self.grid_x = []
		#self.grid_y = []
		self.width = msg.info.width
		self.height = msg.info.height
		self.resolution = msg.info.resolution
		#self.grid_x = self.width * [0.,]
		#self.grid_y = self.height * [0.,]
		self.pose_x = msg.info.origin.position.x
		self.pose_y = msg.info.origin.position.y 

		data = np.array(msg.data)
		current_map = data.reshape(self.height, self.width)
		vector_i = []
		vector_j = []

		self.step = 10
		# Tomar los indices de los obstaculos y almacenarlos
		for i in range(current_map.shape[0]):
			for j in range(current_map.shape[1]):
				if current_map[i][j] == 100:
					vector_i.append(i)
					vector_j.append(j)

		self.gridX = copy.copy(vector_i)
		self.gridY = copy.copy(vector_j)

		self.tamano = len(self.gridX)
		#vector_i = []
		#vector_j = []

		#print("x: ", self.grid_x , "y: ", self.grid_y)


		#return (grid_x, grid_y)


	def publish_xy_map(self):

		self.obst_map.grid_x = self.gridX[0:self.tamano:self.step]
		self.obst_map.grid_y = self.gridY[0:self.tamano:self.step]
		print ("obstacles: ", obst_map)
		self.pub.publish(self.obst_map)


	"""
	def convertCoordinates(self):

		# Convertir los pixeles en coordenadas 
		x = (np.array(self.grid_x) * self.resolution) + self.pose_x
		y = (np.array(self.grid_y) * self.resolution) + self.pose_y

		print ("x: ", x)
		print ("===================================")
		print ("y: ", y)

		tamano = len(x)
		obstacles = np.zeros((tamano,2))
		for n in range(tamano):
			obstacles[n,0] = x[n]
			obstacles[n,1] = y[n]

		#print ("obst: ", obstacles)
		
		#plt.plot(obstacles[:,0],obstacles[:,1],'.')
		#plt.show()

		#print ("obst: ", obstacles)
		"""

if __name__ == '__main__':
	
	rospy.init_node("test_map", anonymous=True)
	slam = SlamInterface()

	rate = rospy.Rate(1)
	while not rospy.is_shutdown():

		slam.publish_xy_map()
		rate.sleep()